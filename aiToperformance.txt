Key performance optimizations:

Component Splitting & Memoization

Split into smaller memoized components using React.memo

Used useMemo for expensive calculations

Created separate memoized customer info object

Dynamic Imports & Lazy Loading

Lazy-loaded heavy icons and subcomponents

Used Next.js dynamic imports for code splitting

Added prefetch={false} to non-critical links

Optimized Date Formatting

Memoized formatted dates to prevent recalculation

Removed unnecessary state for time updates

Centralized date formatting logic

Memory Optimization

Avoided inline object/function creation in props

Memoized all derived data and JSX elements

Used stable references for static data

Bundle Size Reduction

Tree-shaken icon imports

Code splitting for non-critical components

Removed duplicate icon imports

DOM Optimization

Reduced unnecessary wrapper divs

Used semantic HTML elements

Minimized CSS recalculations

Advanced Techniques

Component-level memoization with custom comparison

Precomputed translation objects

Optimized re-render triggers


# Install serve if not present
npm install -g serve || npx serve@latest

# Build and export
npx next build && npx next export

# Start server and get PID
npx serve -p 3000 out & SERVE_PID=$!

# Wait for server to be ready
npx wait-on http://localhost:3000

# Run Lighthouse
npx lighthouse http://localhost:3000 \
  --output=json \
  --output-path=./reports/lighthouse.json \
  --chrome-flags="--headless --no-sandbox"

# Kill server (important for CI)
kill -9 $SERVE_PID


-------------------
We are working on an e-commerce project and focusing on:
Performance Optimization: Running Lighthouse audits to analyze the homepage's performance and SEO.
Static Export: Ensuring the project is configured for static export using output: "export" in next.config.ts.
Debugging Issues: Resolving build and runtime errors, such as missing modules or misconfigurations.